{"ast":null,"code":"// src/index.ts\nimport { readFile } from \"@vercel/edge-config-fs\";\n\n// package.json\nvar name = \"@vercel/edge-config\";\nvar version = \"1.4.0\";\n\n// src/utils/tracing.ts\nvar edgeConfigTraceSymbol = Symbol.for(\"@vercel/edge-config:global-trace\");\nfunction setTracerProvider(tracer) {\n  Reflect.set(globalThis, edgeConfigTraceSymbol, tracer);\n}\nfunction getTracer() {\n  const maybeTraceApi = Reflect.get(globalThis, edgeConfigTraceSymbol);\n  return maybeTraceApi == null ? void 0 : maybeTraceApi.getTracer(name, version);\n}\nfunction isPromise(p) {\n  return p !== null && typeof p === \"object\" && \"then\" in p && typeof p.then === \"function\";\n}\nfunction trace(fn, options = {\n  name: fn.name\n}) {\n  const traced = function (...args) {\n    const tracer = getTracer();\n    if (!tracer) return fn.apply(this, args);\n    const shouldTrace = process.env.EDGE_CONFIG_TRACE_VERBOSE === \"true\" || options.isVerboseTrace === false;\n    if (!shouldTrace) return fn.apply(this, args);\n    return tracer.startActiveSpan(options.name, span => {\n      if (options.attributes) span.setAttributes(options.attributes);\n      try {\n        const result = fn.apply(this, args);\n        if (isPromise(result)) {\n          result.then(value => {\n            if (options.attributesSuccess) {\n              span.setAttributes(options.attributesSuccess(value));\n            }\n            span.setStatus({\n              code: 1\n            });\n            span.end();\n          }).catch(error => {\n            if (options.attributesError) {\n              span.setAttributes(options.attributesError(error));\n            }\n            span.setStatus({\n              code: 2,\n              // 2 = Error\n              message: error instanceof Error ? error.message : void 0\n            });\n            span.end();\n          });\n        } else {\n          if (options.attributesSuccess) {\n            span.setAttributes(options.attributesSuccess(result));\n          }\n          span.setStatus({\n            code: 1\n          });\n          span.end();\n        }\n        return result;\n      } catch (error) {\n        if (options.attributesError) {\n          span.setAttributes(options.attributesError(error));\n        }\n        span.setStatus({\n          code: 2,\n          // 2 = Error\n          message: error instanceof Error ? error.message : void 0\n        });\n        span.end();\n        throw error;\n      }\n    });\n  };\n  return traced;\n}\n\n// src/utils/index.ts\nvar ERRORS = {\n  UNAUTHORIZED: \"@vercel/edge-config: Unauthorized\",\n  EDGE_CONFIG_NOT_FOUND: \"@vercel/edge-config: Edge Config not found\"\n};\nvar UnexpectedNetworkError = class extends Error {\n  constructor(res) {\n    super(`@vercel/edge-config: Unexpected error due to response with status code ${res.status}`);\n  }\n};\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\nfunction pick(obj, keys) {\n  const ret = {};\n  keys.forEach(key => {\n    ret[key] = obj[key];\n  });\n  return ret;\n}\nfunction assertIsKey(key) {\n  if (typeof key !== \"string\") {\n    throw new Error(\"@vercel/edge-config: Expected key to be a string\");\n  }\n}\nfunction isEmptyKey(key) {\n  return key.trim() === \"\";\n}\nfunction assertIsKeys(keys) {\n  if (!Array.isArray(keys) || keys.some(key => typeof key !== \"string\")) {\n    throw new Error(\"@vercel/edge-config: Expected keys to be an array of string\");\n  }\n}\nvar clone = trace(function clone2(value) {\n  if (typeof structuredClone === \"function\") return structuredClone(value);\n  if (value === void 0) return value;\n  return JSON.parse(JSON.stringify(value));\n}, {\n  name: \"clone\"\n});\nfunction parseVercelConnectionStringFromUrl(text) {\n  try {\n    const url = new URL(text);\n    if (url.host !== \"edge-config.vercel.com\") return null;\n    if (url.protocol !== \"https:\") return null;\n    if (!url.pathname.startsWith(\"/ecfg\")) return null;\n    const id = url.pathname.split(\"/\")[1];\n    if (!id) return null;\n    const token = url.searchParams.get(\"token\");\n    if (!token || token === \"\") return null;\n    return {\n      type: \"vercel\",\n      baseUrl: `https://edge-config.vercel.com/${id}`,\n      id,\n      version: \"1\",\n      token\n    };\n  } catch {\n    return null;\n  }\n}\nfunction parseConnectionFromQueryParams(text) {\n  try {\n    if (!text.startsWith(\"edge-config:\")) return null;\n    const params = new URLSearchParams(text.slice(12));\n    const id = params.get(\"id\");\n    const token = params.get(\"token\");\n    if (!id || !token) return null;\n    return {\n      type: \"vercel\",\n      baseUrl: `https://edge-config.vercel.com/${id}`,\n      id,\n      version: \"1\",\n      token\n    };\n  } catch {}\n  return null;\n}\nfunction parseExternalConnectionStringFromUrl(connectionString) {\n  try {\n    const url = new URL(connectionString);\n    let id = url.searchParams.get(\"id\");\n    const token = url.searchParams.get(\"token\");\n    const version2 = url.searchParams.get(\"version\") || \"1\";\n    if (!id || url.pathname.startsWith(\"/ecfg_\")) {\n      id = url.pathname.split(\"/\")[1] || null;\n    }\n    if (!id || !token) return null;\n    url.search = \"\";\n    return {\n      type: \"external\",\n      baseUrl: url.toString(),\n      id,\n      token,\n      version: version2\n    };\n  } catch {\n    return null;\n  }\n}\nfunction parseConnectionString(connectionString) {\n  return parseConnectionFromQueryParams(connectionString) || parseVercelConnectionStringFromUrl(connectionString) || parseExternalConnectionStringFromUrl(connectionString);\n}\n\n// src/utils/fetch-with-cached-response.ts\nfunction createResponse(cachedResponseEntry) {\n  return new Response(cachedResponseEntry.response, {\n    headers: {\n      ...cachedResponseEntry.headers,\n      Age: String(\n      // age header may not be 0 when serving stale content, must be >= 1\n      Math.max(1, Math.floor((Date.now() - cachedResponseEntry.time) / 1e3)))\n    },\n    status: cachedResponseEntry.status\n  });\n}\nfunction createHandleStaleIfError(cachedResponseEntry, staleIfError) {\n  return function handleStaleIfError(response) {\n    switch (response.status) {\n      case 500:\n      case 502:\n      case 503:\n      case 504:\n        return typeof staleIfError === \"number\" && cachedResponseEntry.time < Date.now() + staleIfError * 1e3 ? createResponse(cachedResponseEntry) : response;\n      default:\n        return response;\n    }\n  };\n}\nfunction createHandleStaleIfErrorException(cachedResponseEntry, staleIfError) {\n  return function handleStaleIfError(reason) {\n    if (typeof staleIfError === \"number\" && cachedResponseEntry.time < Date.now() + staleIfError * 1e3) {\n      return createResponse(cachedResponseEntry);\n    }\n    throw reason;\n  };\n}\nvar cache = /* @__PURE__ */new Map();\nfunction extractStaleIfError(cacheControlHeader) {\n  if (!cacheControlHeader) return null;\n  const matched = /stale-if-error=(?<staleIfError>\\d+)/i.exec(cacheControlHeader);\n  return (matched == null ? void 0 : matched.groups) ? Number(matched.groups.staleIfError) : null;\n}\nvar fetchWithCachedResponse = trace(async function fetchWithCachedResponse2(url, options = {}) {\n  const {\n    headers: customHeaders = new Headers(),\n    ...customOptions\n  } = options;\n  const authHeader = customHeaders.get(\"Authorization\");\n  const cacheKey = `${url},${authHeader || \"\"}`;\n  const cachedResponseEntry = cache.get(cacheKey);\n  if (cachedResponseEntry) {\n    const {\n      etag: etag2,\n      response: cachedResponse\n    } = cachedResponseEntry;\n    const headers = new Headers(customHeaders);\n    headers.set(\"If-None-Match\", etag2);\n    const staleIfError = extractStaleIfError(headers.get(\"Cache-Control\"));\n    const res2 = await fetch(url, {\n      ...customOptions,\n      headers\n    }).then(createHandleStaleIfError(cachedResponseEntry, staleIfError), createHandleStaleIfErrorException(cachedResponseEntry, staleIfError));\n    if (res2.status === 304) {\n      res2.cachedResponseBody = JSON.parse(cachedResponse);\n      return res2;\n    }\n    const newETag = res2.headers.get(\"ETag\");\n    if (res2.ok && newETag) cache.set(cacheKey, {\n      etag: newETag,\n      response: await res2.clone().text(),\n      headers: Object.fromEntries(res2.headers.entries()),\n      status: res2.status,\n      time: Date.now()\n    });\n    return res2;\n  }\n  const res = await fetch(url, options);\n  const etag = res.headers.get(\"ETag\");\n  if (res.ok && etag) {\n    cache.set(cacheKey, {\n      etag,\n      response: await res.clone().text(),\n      headers: Object.fromEntries(res.headers.entries()),\n      status: res.status,\n      time: Date.now()\n    });\n  }\n  return res;\n}, {\n  name: \"fetchWithCachedResponse\",\n  attributesSuccess(result) {\n    return {\n      status: result.status\n    };\n  }\n});\n\n// src/index.ts\nvar jsonParseCache = /* @__PURE__ */new Map();\nvar readFileTraced = trace(readFile, {\n  name: \"readFile\"\n});\nvar jsonParseTraced = trace(JSON.parse, {\n  name: \"JSON.parse\"\n});\nvar privateEdgeConfigSymbol = Symbol.for(\"privateEdgeConfig\");\nvar cachedJsonParseTraced = trace((edgeConfigId, content) => {\n  const cached = jsonParseCache.get(edgeConfigId);\n  if (cached) return cached;\n  const parsed = jsonParseTraced(content);\n  jsonParseCache.set(edgeConfigId, Object.freeze(parsed));\n  return parsed;\n}, {\n  name: \"cached JSON.parse\"\n});\nvar getFileSystemEdgeConfig = trace(async function getFileSystemEdgeConfig2(connection) {\n  if (connection.type !== \"vercel\") return null;\n  if (!process.env.AWS_LAMBDA_FUNCTION_NAME) return null;\n  try {\n    const content = await readFileTraced(`/opt/edge-config/${connection.id}.json`, \"utf-8\");\n    return cachedJsonParseTraced(connection.id, content);\n  } catch {\n    return null;\n  }\n}, {\n  name: \"getFileSystemEdgeConfig\"\n});\nvar getPrivateEdgeConfig = trace(async function getPrivateEdgeConfig2(connection) {\n  const privateEdgeConfig = Reflect.get(globalThis, privateEdgeConfigSymbol);\n  if (typeof privateEdgeConfig === \"object\" && typeof privateEdgeConfig.get === \"function\") {\n    return privateEdgeConfig.get(connection.id);\n  }\n  return null;\n}, {\n  name: \"getPrivateEdgeConfig\"\n});\nfunction createGetInMemoryEdgeConfig(shouldUseDevelopmentCache, connection, headers, fetchCache) {\n  let embeddedEdgeConfigPromise = null;\n  let latestRequest = null;\n  return trace(localOptions => {\n    if ((localOptions == null ? void 0 : localOptions.consistentRead) || !shouldUseDevelopmentCache) return Promise.resolve(null);\n    if (!latestRequest) {\n      latestRequest = fetchWithCachedResponse(`${connection.baseUrl}/items?version=${connection.version}`, {\n        headers: new Headers(headers),\n        cache: fetchCache\n      }).then(async res => {\n        const digest2 = res.headers.get(\"x-edge-config-digest\");\n        let body;\n        if (!res.ok) {\n          await consumeResponseBody(res);\n          body = res.cachedResponseBody;\n          if (!body) return null;\n        } else {\n          body = await res.json();\n        }\n        return {\n          digest: digest2,\n          items: body\n        };\n      });\n      latestRequest.then(resolved => {\n        embeddedEdgeConfigPromise = Promise.resolve(resolved);\n        latestRequest = null;\n      },\n      // Attach a `.catch` handler to this promise so that if it does throw,\n      // we don't get an unhandled promise rejection event. We unset the\n      // `latestRequest` so that the next call will make a new request.\n      () => {\n        embeddedEdgeConfigPromise = null;\n        latestRequest = null;\n      });\n    }\n    if (!embeddedEdgeConfigPromise) {\n      embeddedEdgeConfigPromise = latestRequest;\n    }\n    return embeddedEdgeConfigPromise;\n  }, {\n    name: \"getInMemoryEdgeConfig\"\n  });\n}\nfunction addConsistentReadHeader(headers) {\n  headers.set(\"x-edge-config-min-updated-at\", `${Number.MAX_SAFE_INTEGER}`);\n}\nasync function getLocalEdgeConfig(connection, options) {\n  if (options == null ? void 0 : options.consistentRead) return null;\n  const edgeConfig = (await getPrivateEdgeConfig(connection)) || (await getFileSystemEdgeConfig(connection));\n  return edgeConfig;\n}\nasync function consumeResponseBody(res) {\n  await res.arrayBuffer();\n}\nvar createClient = trace(function createClient2(connectionString, options = {\n  staleIfError: 604800,\n  cache: \"no-store\"\n}) {\n  if (!connectionString) throw new Error(\"@vercel/edge-config: No connection string provided\");\n  const connection = parseConnectionString(connectionString);\n  if (!connection) throw new Error(\"@vercel/edge-config: Invalid connection string provided\");\n  const edgeConfigId = connection.id;\n  const baseUrl = connection.baseUrl;\n  const version2 = connection.version;\n  const headers = {\n    Authorization: `Bearer ${connection.token}`\n  };\n  if (typeof process !== \"undefined\" && process.env.VERCEL_ENV) headers[\"x-edge-config-vercel-env\"] = process.env.VERCEL_ENV;\n  if (typeof name === \"string\" && typeof version === \"string\") headers[\"x-edge-config-sdk\"] = `${name}@${version}`;\n  if (typeof options.staleIfError === \"number\" && options.staleIfError > 0) headers[\"cache-control\"] = `stale-if-error=${options.staleIfError}`;\n  const fetchCache = options.cache || \"no-store\";\n  const shouldUseDevelopmentCache = !options.disableDevelopmentCache && process.env.NODE_ENV === \"development\" && process.env.EDGE_CONFIG_DISABLE_DEVELOPMENT_SWR !== \"1\";\n  const getInMemoryEdgeConfig = createGetInMemoryEdgeConfig(shouldUseDevelopmentCache, connection, headers, fetchCache);\n  const api = {\n    get: trace(async function get2(key, localOptions) {\n      const localEdgeConfig = (await getInMemoryEdgeConfig(localOptions)) || (await getLocalEdgeConfig(connection, localOptions));\n      assertIsKey(key);\n      if (isEmptyKey(key)) return void 0;\n      if (localEdgeConfig) {\n        return Promise.resolve(localEdgeConfig.items[key]);\n      }\n      const localHeaders = new Headers(headers);\n      if (localOptions == null ? void 0 : localOptions.consistentRead) addConsistentReadHeader(localHeaders);\n      return fetchWithCachedResponse(`${baseUrl}/item/${key}?version=${version2}`, {\n        headers: localHeaders,\n        cache: fetchCache\n      }).then(async res => {\n        if (res.ok) return res.json();\n        await consumeResponseBody(res);\n        if (res.status === 401) throw new Error(ERRORS.UNAUTHORIZED);\n        if (res.status === 404) {\n          if (res.headers.has(\"x-edge-config-digest\")) return void 0;\n          throw new Error(ERRORS.EDGE_CONFIG_NOT_FOUND);\n        }\n        if (res.cachedResponseBody !== void 0) return res.cachedResponseBody;\n        throw new UnexpectedNetworkError(res);\n      });\n    }, {\n      name: \"get\",\n      isVerboseTrace: false,\n      attributes: {\n        edgeConfigId\n      }\n    }),\n    has: trace(async function has2(key, localOptions) {\n      const localEdgeConfig = (await getInMemoryEdgeConfig(localOptions)) || (await getLocalEdgeConfig(connection, localOptions));\n      assertIsKey(key);\n      if (isEmptyKey(key)) return false;\n      if (localEdgeConfig) {\n        return Promise.resolve(hasOwnProperty(localEdgeConfig.items, key));\n      }\n      const localHeaders = new Headers(headers);\n      if (localOptions == null ? void 0 : localOptions.consistentRead) addConsistentReadHeader(localHeaders);\n      return fetch(`${baseUrl}/item/${key}?version=${version2}`, {\n        method: \"HEAD\",\n        headers: localHeaders,\n        cache: fetchCache\n      }).then(res => {\n        if (res.status === 401) throw new Error(ERRORS.UNAUTHORIZED);\n        if (res.status === 404) {\n          if (res.headers.has(\"x-edge-config-digest\")) return false;\n          throw new Error(ERRORS.EDGE_CONFIG_NOT_FOUND);\n        }\n        if (res.ok) return true;\n        throw new UnexpectedNetworkError(res);\n      });\n    }, {\n      name: \"has\",\n      isVerboseTrace: false,\n      attributes: {\n        edgeConfigId\n      }\n    }),\n    getAll: trace(async function getAll2(keys, localOptions) {\n      const localEdgeConfig = (await getInMemoryEdgeConfig(localOptions)) || (await getLocalEdgeConfig(connection, localOptions));\n      if (localEdgeConfig) {\n        if (keys === void 0) {\n          return Promise.resolve(localEdgeConfig.items);\n        }\n        assertIsKeys(keys);\n        return Promise.resolve(pick(localEdgeConfig.items, keys));\n      }\n      if (Array.isArray(keys)) assertIsKeys(keys);\n      const search = Array.isArray(keys) ? new URLSearchParams(keys.filter(key => typeof key === \"string\" && !isEmptyKey(key)).map(key => [\"key\", key])).toString() : null;\n      if (search === \"\") return Promise.resolve({});\n      const localHeaders = new Headers(headers);\n      if (localOptions == null ? void 0 : localOptions.consistentRead) addConsistentReadHeader(localHeaders);\n      return fetchWithCachedResponse(`${baseUrl}/items?version=${version2}${search === null ? \"\" : `&${search}`}`, {\n        headers: localHeaders,\n        cache: fetchCache\n      }).then(async res => {\n        if (res.ok) return res.json();\n        await consumeResponseBody(res);\n        if (res.status === 401) throw new Error(ERRORS.UNAUTHORIZED);\n        if (res.status === 404) throw new Error(ERRORS.EDGE_CONFIG_NOT_FOUND);\n        if (res.cachedResponseBody !== void 0) return res.cachedResponseBody;\n        throw new UnexpectedNetworkError(res);\n      });\n    }, {\n      name: \"getAll\",\n      isVerboseTrace: false,\n      attributes: {\n        edgeConfigId\n      }\n    }),\n    digest: trace(async function digest2(localOptions) {\n      const localEdgeConfig = (await getInMemoryEdgeConfig(localOptions)) || (await getLocalEdgeConfig(connection, localOptions));\n      if (localEdgeConfig) {\n        return Promise.resolve(localEdgeConfig.digest);\n      }\n      const localHeaders = new Headers(headers);\n      if (localOptions == null ? void 0 : localOptions.consistentRead) addConsistentReadHeader(localHeaders);\n      return fetchWithCachedResponse(`${baseUrl}/digest?version=${version2}`, {\n        headers: localHeaders,\n        cache: fetchCache\n      }).then(async res => {\n        if (res.ok) return res.json();\n        await consumeResponseBody(res);\n        if (res.cachedResponseBody !== void 0) return res.cachedResponseBody;\n        throw new UnexpectedNetworkError(res);\n      });\n    }, {\n      name: \"digest\",\n      isVerboseTrace: false,\n      attributes: {\n        edgeConfigId\n      }\n    })\n  };\n  return {\n    ...api,\n    connection\n  };\n}, {\n  name: \"createClient\"\n});\nvar defaultEdgeConfigClient;\nfunction init() {\n  if (!defaultEdgeConfigClient) {\n    defaultEdgeConfigClient = createClient(process.env.EDGE_CONFIG);\n  }\n}\nvar get = (...args) => {\n  init();\n  return defaultEdgeConfigClient.get(...args);\n};\nvar getAll = (...args) => {\n  init();\n  return defaultEdgeConfigClient.getAll(...args);\n};\nvar has = (...args) => {\n  init();\n  return defaultEdgeConfigClient.has(...args);\n};\nvar digest = (...args) => {\n  init();\n  return defaultEdgeConfigClient.digest(...args);\n};\nfunction clone3(edgeConfigValue) {\n  return JSON.parse(JSON.stringify(edgeConfigValue));\n}\nexport { clone3 as clone, createClient, digest, get, getAll, has, parseConnectionString, setTracerProvider };","map":{"version":3,"names":["readFile","name","version","edgeConfigTraceSymbol","Symbol","for","setTracerProvider","tracer","Reflect","set","globalThis","getTracer","maybeTraceApi","get","isPromise","p","then","trace","fn","options","traced","args","apply","shouldTrace","process","env","EDGE_CONFIG_TRACE_VERBOSE","isVerboseTrace","startActiveSpan","span","attributes","setAttributes","result","value","attributesSuccess","setStatus","code","end","catch","error","attributesError","message","Error","ERRORS","UNAUTHORIZED","EDGE_CONFIG_NOT_FOUND","UnexpectedNetworkError","constructor","res","status","hasOwnProperty","obj","prop","Object","prototype","call","pick","keys","ret","forEach","key","assertIsKey","isEmptyKey","trim","assertIsKeys","Array","isArray","some","clone","clone2","structuredClone","JSON","parse","stringify","parseVercelConnectionStringFromUrl","text","url","URL","host","protocol","pathname","startsWith","id","split","token","searchParams","type","baseUrl","parseConnectionFromQueryParams","params","URLSearchParams","slice","parseExternalConnectionStringFromUrl","connectionString","version2","search","toString","parseConnectionString","createResponse","cachedResponseEntry","Response","response","headers","Age","String","Math","max","floor","Date","now","time","createHandleStaleIfError","staleIfError","handleStaleIfError","createHandleStaleIfErrorException","reason","cache","Map","extractStaleIfError","cacheControlHeader","matched","exec","groups","Number","fetchWithCachedResponse","fetchWithCachedResponse2","customHeaders","Headers","customOptions","authHeader","cacheKey","etag","etag2","cachedResponse","res2","fetch","cachedResponseBody","newETag","ok","fromEntries","entries","jsonParseCache","readFileTraced","jsonParseTraced","privateEdgeConfigSymbol","cachedJsonParseTraced","edgeConfigId","content","cached","parsed","freeze","getFileSystemEdgeConfig","getFileSystemEdgeConfig2","connection","AWS_LAMBDA_FUNCTION_NAME","getPrivateEdgeConfig","getPrivateEdgeConfig2","privateEdgeConfig","createGetInMemoryEdgeConfig","shouldUseDevelopmentCache","fetchCache","embeddedEdgeConfigPromise","latestRequest","localOptions","consistentRead","Promise","resolve","digest2","body","consumeResponseBody","json","digest","items","resolved","addConsistentReadHeader","MAX_SAFE_INTEGER","getLocalEdgeConfig","edgeConfig","arrayBuffer","createClient","createClient2","Authorization","VERCEL_ENV","disableDevelopmentCache","NODE_ENV","EDGE_CONFIG_DISABLE_DEVELOPMENT_SWR","getInMemoryEdgeConfig","api","get2","localEdgeConfig","localHeaders","has","has2","method","getAll","getAll2","filter","map","defaultEdgeConfigClient","init","EDGE_CONFIG","clone3","edgeConfigValue"],"sources":["/home/mahim00zz/Climate_Aware/climate-dashboard/client/node_modules/@vercel/edge-config/src/index.ts","/home/mahim00zz/Climate_Aware/climate-dashboard/client/node_modules/@vercel/edge-config/package.json","/home/mahim00zz/Climate_Aware/climate-dashboard/client/node_modules/@vercel/edge-config/src/utils/tracing.ts","/home/mahim00zz/Climate_Aware/climate-dashboard/client/node_modules/@vercel/edge-config/src/utils/index.ts","/home/mahim00zz/Climate_Aware/climate-dashboard/client/node_modules/@vercel/edge-config/src/utils/fetch-with-cached-response.ts"],"sourcesContent":["import { readFile } from '@vercel/edge-config-fs';\nimport { name as sdkName, version as sdkVersion } from '../package.json';\nimport {\n  assertIsKey,\n  assertIsKeys,\n  isEmptyKey,\n  ERRORS,\n  UnexpectedNetworkError,\n  hasOwnProperty,\n  parseConnectionString,\n  pick,\n} from './utils';\nimport type {\n  Connection,\n  EdgeConfigClient,\n  EdgeConfigItems,\n  EdgeConfigValue,\n  EmbeddedEdgeConfig,\n  EdgeConfigFunctionsOptions,\n} from './types';\nimport { fetchWithCachedResponse } from './utils/fetch-with-cached-response';\nimport { trace } from './utils/tracing';\n\nexport { setTracerProvider } from './utils/tracing';\n\nexport {\n  parseConnectionString,\n  type EdgeConfigClient,\n  type EdgeConfigItems,\n  type EdgeConfigValue,\n  type EmbeddedEdgeConfig,\n};\n\nconst jsonParseCache = new Map<string, unknown>();\n\nconst readFileTraced = trace(readFile, { name: 'readFile' });\nconst jsonParseTraced = trace(JSON.parse, { name: 'JSON.parse' });\n\nconst privateEdgeConfigSymbol = Symbol.for('privateEdgeConfig');\n\nconst cachedJsonParseTraced = trace(\n  (edgeConfigId: string, content: string) => {\n    const cached = jsonParseCache.get(edgeConfigId);\n    if (cached) return cached;\n\n    const parsed = jsonParseTraced(content) as unknown;\n\n    // freeze the object to avoid mutations of the return value of a \"get\" call\n    // from affecting the return value of future \"get\" calls\n    jsonParseCache.set(edgeConfigId, Object.freeze(parsed));\n    return parsed;\n  },\n  { name: 'cached JSON.parse' },\n);\n\n/**\n * Reads an Edge Config from the local file system.\n * This is used at runtime on serverless functions.\n */\nconst getFileSystemEdgeConfig = trace(\n  async function getFileSystemEdgeConfig(\n    connection: Connection,\n  ): Promise<EmbeddedEdgeConfig | null> {\n    // can't optimize non-vercel hosted edge configs\n    if (connection.type !== 'vercel') return null;\n    // can't use fs optimizations outside of lambda\n    if (!process.env.AWS_LAMBDA_FUNCTION_NAME) return null;\n\n    try {\n      const content = await readFileTraced(\n        `/opt/edge-config/${connection.id}.json`,\n        'utf-8',\n      );\n\n      return cachedJsonParseTraced(\n        connection.id,\n        content,\n      ) as EmbeddedEdgeConfig;\n    } catch {\n      return null;\n    }\n  },\n  {\n    name: 'getFileSystemEdgeConfig',\n  },\n);\n\n/**\n * Will return an embedded Edge Config object from memory,\n * but only when the `privateEdgeConfigSymbol` is in global scope.\n */\nconst getPrivateEdgeConfig = trace(\n  async function getPrivateEdgeConfig(\n    connection: Connection,\n  ): Promise<EmbeddedEdgeConfig | null> {\n    const privateEdgeConfig = Reflect.get(\n      globalThis,\n      privateEdgeConfigSymbol,\n    ) as\n      | {\n          get: (id: string) => Promise<EmbeddedEdgeConfig | null>;\n        }\n      | undefined;\n\n    if (\n      typeof privateEdgeConfig === 'object' &&\n      typeof privateEdgeConfig.get === 'function'\n    ) {\n      return privateEdgeConfig.get(connection.id);\n    }\n\n    return null;\n  },\n  {\n    name: 'getPrivateEdgeConfig',\n  },\n);\n\n/**\n * Returns a function to retrieve the entire Edge Config.\n * It'll keep the fetched Edge Config in memory, making subsequent calls fast,\n * while revalidating in the background.\n */\nfunction createGetInMemoryEdgeConfig(\n  shouldUseDevelopmentCache: boolean,\n  connection: Connection,\n  headers: Record<string, string>,\n  fetchCache: EdgeConfigClientOptions['cache'],\n): (\n  localOptions?: EdgeConfigFunctionsOptions,\n) => Promise<EmbeddedEdgeConfig | null> {\n  // Functions as cache to keep track of the Edge Config.\n  let embeddedEdgeConfigPromise: Promise<EmbeddedEdgeConfig | null> | null =\n    null;\n\n  // Promise that points to the most recent request.\n  // It'll ensure that subsequent calls won't make another fetch call,\n  // while one is still on-going.\n  // Will overwrite `embeddedEdgeConfigPromise` only when resolved.\n  let latestRequest: Promise<EmbeddedEdgeConfig | null> | null = null;\n\n  return trace(\n    (localOptions) => {\n      if (localOptions?.consistentRead || !shouldUseDevelopmentCache)\n        return Promise.resolve(null);\n\n      if (!latestRequest) {\n        latestRequest = fetchWithCachedResponse(\n          `${connection.baseUrl}/items?version=${connection.version}`,\n          {\n            headers: new Headers(headers),\n            cache: fetchCache,\n          },\n        ).then(async (res) => {\n          const digest = res.headers.get('x-edge-config-digest');\n          let body: EdgeConfigValue | undefined;\n\n          // We ignore all errors here and just proceed.\n          if (!res.ok) {\n            await consumeResponseBody(res);\n            body = res.cachedResponseBody as EdgeConfigValue | undefined;\n            if (!body) return null;\n          } else {\n            body = (await res.json()) as EdgeConfigItems;\n          }\n\n          return { digest, items: body } as EmbeddedEdgeConfig;\n        });\n\n        // Once the request is resolved, we set the proper config to the promise\n        // such that the next call will return the resolved value.\n        latestRequest.then(\n          (resolved) => {\n            embeddedEdgeConfigPromise = Promise.resolve(resolved);\n            latestRequest = null;\n          },\n          // Attach a `.catch` handler to this promise so that if it does throw,\n          // we don't get an unhandled promise rejection event. We unset the\n          // `latestRequest` so that the next call will make a new request.\n          () => {\n            embeddedEdgeConfigPromise = null;\n            latestRequest = null;\n          },\n        );\n      }\n\n      if (!embeddedEdgeConfigPromise) {\n        // If the `embeddedEdgeConfigPromise` is `null`, it means that there's\n        // no previous request, so we'll set the `latestRequest` to the current\n        // request.\n        embeddedEdgeConfigPromise = latestRequest;\n      }\n\n      return embeddedEdgeConfigPromise;\n    },\n    {\n      name: 'getInMemoryEdgeConfig',\n    },\n  );\n}\n\n/**\n * Uses `MAX_SAFE_INTEGER` as minimum updated at timestamp to force\n * a request to the origin.\n */\nfunction addConsistentReadHeader(headers: Headers): void {\n  headers.set('x-edge-config-min-updated-at', `${Number.MAX_SAFE_INTEGER}`);\n}\n\n/**\n * Reads the Edge Config from a local provider, if available,\n * to avoid Network requests.\n */\nasync function getLocalEdgeConfig(\n  connection: Connection,\n  options?: EdgeConfigFunctionsOptions,\n): Promise<EmbeddedEdgeConfig | null> {\n  if (options?.consistentRead) return null;\n\n  const edgeConfig =\n    (await getPrivateEdgeConfig(connection)) ||\n    (await getFileSystemEdgeConfig(connection));\n\n  return edgeConfig;\n}\n\n/**\n * This function reads the respone body\n *\n * Reading the response body serves two purposes\n *\n * 1) In Node.js it avoids memory leaks\n *\n * See https://github.com/nodejs/undici/blob/v5.21.2/README.md#garbage-collection\n * See https://github.com/node-fetch/node-fetch/issues/83\n *\n * 2) In Cloudflare it avoids running into a deadlock. They have a maximum number\n * of concurrent fetches (which is documented). Concurrency counts until the\n * body of a response is read. It is not uncommon to never read a response body\n * (e.g. if you only care about the status code). This can lead to deadlock as\n * fetches appear to never resolve.\n *\n * See https://developers.cloudflare.com/workers/platform/limits/#simultaneous-open-connections\n */\nasync function consumeResponseBody(res: Response): Promise<void> {\n  await res.arrayBuffer();\n}\n\ninterface EdgeConfigClientOptions {\n  /**\n   * The stale-if-error response directive indicates that the cache can reuse a\n   * stale response when an upstream server generates an error, or when the error\n   * is generated locally - for example due to a connection error.\n   *\n   * Any response with a status code of 500, 502, 503, or 504 is considered an error.\n   *\n   * Pass a negative number, 0, or false to turn disable stale-if-error semantics.\n   *\n   * The time is supplied in seconds. Defaults to one week (`604800`).\n   */\n  staleIfError?: number | false;\n  /**\n   * In development, a stale-while-revalidate cache is employed as the default caching strategy.\n   *\n   * This cache aims to deliver speedy Edge Config reads during development, though it comes\n   * at the cost of delayed visibility for updates to Edge Config. Typically, you may need to\n   * refresh twice to observe these changes as the stale value is replaced.\n   *\n   * This cache is not used in preview or production deployments as superior optimisations are applied there.\n   */\n  disableDevelopmentCache?: boolean;\n\n  /**\n   * Sets a `cache` option on the `fetch` call made by Edge Config.\n   *\n   * Unlike Next.js, this defaults to `no-store`, as you most likely want to use Edge Config dynamically.\n   */\n  cache?: 'no-store' | 'force-cache';\n}\n\n/**\n * Create an Edge Config client.\n *\n * The client has multiple methods which allow you to read the Edge Config.\n *\n * If you need to programmatically write to an Edge Config, check out the [Update your Edge Config items](https://vercel.com/docs/storage/edge-config/vercel-api#update-your-edge-config-items) section.\n *\n * @param connectionString - A connection string. Usually you'd pass in `process.env.EDGE_CONFIG` here, which contains a connection string.\n * @returns An Edge Config Client instance\n */\nexport const createClient = trace(\n  function createClient(\n    connectionString: string | undefined,\n    options: EdgeConfigClientOptions = {\n      staleIfError: 604800 /* one week */,\n      cache: 'no-store',\n    },\n  ): EdgeConfigClient {\n    if (!connectionString)\n      throw new Error('@vercel/edge-config: No connection string provided');\n\n    const connection = parseConnectionString(connectionString);\n\n    if (!connection)\n      throw new Error(\n        '@vercel/edge-config: Invalid connection string provided',\n      );\n\n    const edgeConfigId = connection.id;\n    const baseUrl = connection.baseUrl;\n    const version = connection.version; // version of the edge config read access api we talk to\n    const headers: Record<string, string> = {\n      Authorization: `Bearer ${connection.token}`,\n    };\n\n    // eslint-disable-next-line @typescript-eslint/prefer-optional-chain -- [@vercel/style-guide@5 migration]\n    if (typeof process !== 'undefined' && process.env.VERCEL_ENV)\n      headers['x-edge-config-vercel-env'] = process.env.VERCEL_ENV;\n\n    if (typeof sdkName === 'string' && typeof sdkVersion === 'string')\n      headers['x-edge-config-sdk'] = `${sdkName}@${sdkVersion}`;\n\n    if (typeof options.staleIfError === 'number' && options.staleIfError > 0)\n      headers['cache-control'] = `stale-if-error=${options.staleIfError}`;\n\n    const fetchCache = options.cache || 'no-store';\n\n    /**\n     * While in development we use SWR-like behavior for the api client to\n     * reduce latency.\n     */\n    const shouldUseDevelopmentCache =\n      !options.disableDevelopmentCache &&\n      process.env.NODE_ENV === 'development' &&\n      process.env.EDGE_CONFIG_DISABLE_DEVELOPMENT_SWR !== '1';\n\n    const getInMemoryEdgeConfig = createGetInMemoryEdgeConfig(\n      shouldUseDevelopmentCache,\n      connection,\n      headers,\n      fetchCache,\n    );\n\n    const api: Omit<EdgeConfigClient, 'connection'> = {\n      get: trace(\n        async function get<T = EdgeConfigValue>(\n          key: string,\n          localOptions?: EdgeConfigFunctionsOptions,\n        ): Promise<T | undefined> {\n          const localEdgeConfig =\n            (await getInMemoryEdgeConfig(localOptions)) ||\n            (await getLocalEdgeConfig(connection, localOptions));\n\n          assertIsKey(key);\n          if (isEmptyKey(key)) return undefined;\n\n          if (localEdgeConfig) {\n            // We need to return a clone of the value so users can't modify\n            // our original value, and so the reference changes.\n            //\n            // This makes it consistent with the real API.\n            return Promise.resolve(localEdgeConfig.items[key] as T);\n          }\n\n          const localHeaders = new Headers(headers);\n          if (localOptions?.consistentRead)\n            addConsistentReadHeader(localHeaders);\n\n          return fetchWithCachedResponse(\n            `${baseUrl}/item/${key}?version=${version}`,\n            {\n              headers: localHeaders,\n              cache: fetchCache,\n            },\n          ).then<T | undefined, undefined>(async (res) => {\n            if (res.ok) return res.json();\n            await consumeResponseBody(res);\n\n            if (res.status === 401) throw new Error(ERRORS.UNAUTHORIZED);\n            if (res.status === 404) {\n              // if the x-edge-config-digest header is present, it means\n              // the edge config exists, but the item does not\n              if (res.headers.has('x-edge-config-digest')) return undefined;\n              // if the x-edge-config-digest header is not present, it means\n              // the edge config itself does not exist\n              throw new Error(ERRORS.EDGE_CONFIG_NOT_FOUND);\n            }\n            if (res.cachedResponseBody !== undefined)\n              return res.cachedResponseBody as T;\n            throw new UnexpectedNetworkError(res);\n          });\n        },\n        { name: 'get', isVerboseTrace: false, attributes: { edgeConfigId } },\n      ),\n      has: trace(\n        async function has(\n          key,\n          localOptions?: EdgeConfigFunctionsOptions,\n        ): Promise<boolean> {\n          const localEdgeConfig =\n            (await getInMemoryEdgeConfig(localOptions)) ||\n            (await getLocalEdgeConfig(connection, localOptions));\n\n          assertIsKey(key);\n          if (isEmptyKey(key)) return false;\n\n          if (localEdgeConfig) {\n            return Promise.resolve(hasOwnProperty(localEdgeConfig.items, key));\n          }\n\n          const localHeaders = new Headers(headers);\n          if (localOptions?.consistentRead)\n            addConsistentReadHeader(localHeaders);\n\n          // this is a HEAD request anyhow, no need for fetchWithCachedResponse\n          return fetch(`${baseUrl}/item/${key}?version=${version}`, {\n            method: 'HEAD',\n            headers: localHeaders,\n            cache: fetchCache,\n          }).then((res) => {\n            if (res.status === 401) throw new Error(ERRORS.UNAUTHORIZED);\n            if (res.status === 404) {\n              // if the x-edge-config-digest header is present, it means\n              // the edge config exists, but the item does not\n              if (res.headers.has('x-edge-config-digest')) return false;\n              // if the x-edge-config-digest header is not present, it means\n              // the edge config itself does not exist\n              throw new Error(ERRORS.EDGE_CONFIG_NOT_FOUND);\n            }\n            if (res.ok) return true;\n            throw new UnexpectedNetworkError(res);\n          });\n        },\n        { name: 'has', isVerboseTrace: false, attributes: { edgeConfigId } },\n      ),\n      getAll: trace(\n        async function getAll<T = EdgeConfigItems>(\n          keys?: (keyof T)[],\n          localOptions?: EdgeConfigFunctionsOptions,\n        ): Promise<T> {\n          const localEdgeConfig =\n            (await getInMemoryEdgeConfig(localOptions)) ||\n            (await getLocalEdgeConfig(connection, localOptions));\n\n          if (localEdgeConfig) {\n            if (keys === undefined) {\n              return Promise.resolve(localEdgeConfig.items as T);\n            }\n\n            assertIsKeys(keys);\n            return Promise.resolve(pick(localEdgeConfig.items, keys) as T);\n          }\n\n          if (Array.isArray(keys)) assertIsKeys(keys);\n\n          const search = Array.isArray(keys)\n            ? new URLSearchParams(\n                keys\n                  .filter((key) => typeof key === 'string' && !isEmptyKey(key))\n                  .map((key) => ['key', key] as [string, string]),\n              ).toString()\n            : null;\n\n          // empty search keys array was given,\n          // so skip the request and return an empty object\n          if (search === '') return Promise.resolve({} as T);\n\n          const localHeaders = new Headers(headers);\n          if (localOptions?.consistentRead)\n            addConsistentReadHeader(localHeaders);\n\n          return fetchWithCachedResponse(\n            `${baseUrl}/items?version=${version}${\n              search === null ? '' : `&${search}`\n            }`,\n            {\n              headers: localHeaders,\n              cache: fetchCache,\n            },\n          ).then<T>(async (res) => {\n            if (res.ok) return res.json();\n            await consumeResponseBody(res);\n\n            if (res.status === 401) throw new Error(ERRORS.UNAUTHORIZED);\n            // the /items endpoint never returns 404, so if we get a 404\n            // it means the edge config itself did not exist\n            if (res.status === 404)\n              throw new Error(ERRORS.EDGE_CONFIG_NOT_FOUND);\n            if (res.cachedResponseBody !== undefined)\n              return res.cachedResponseBody as T;\n            throw new UnexpectedNetworkError(res);\n          });\n        },\n        { name: 'getAll', isVerboseTrace: false, attributes: { edgeConfigId } },\n      ),\n      digest: trace(\n        async function digest(\n          localOptions?: EdgeConfigFunctionsOptions,\n        ): Promise<string> {\n          const localEdgeConfig =\n            (await getInMemoryEdgeConfig(localOptions)) ||\n            (await getLocalEdgeConfig(connection, localOptions));\n\n          if (localEdgeConfig) {\n            return Promise.resolve(localEdgeConfig.digest);\n          }\n\n          const localHeaders = new Headers(headers);\n          if (localOptions?.consistentRead)\n            addConsistentReadHeader(localHeaders);\n\n          return fetchWithCachedResponse(\n            `${baseUrl}/digest?version=${version}`,\n            {\n              headers: localHeaders,\n              cache: fetchCache,\n            },\n          ).then(async (res) => {\n            if (res.ok) return res.json() as Promise<string>;\n            await consumeResponseBody(res);\n\n            if (res.cachedResponseBody !== undefined)\n              return res.cachedResponseBody as string;\n            throw new UnexpectedNetworkError(res);\n          });\n        },\n        { name: 'digest', isVerboseTrace: false, attributes: { edgeConfigId } },\n      ),\n    };\n\n    return { ...api, connection };\n  },\n  {\n    name: 'createClient',\n  },\n);\n\nlet defaultEdgeConfigClient: EdgeConfigClient;\n\n// lazy init fn so the default edge config does not throw in case\n// process.env.EDGE_CONFIG is not defined and its methods are never used.\nfunction init(): void {\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- [@vercel/style-guide@5 migration]\n  if (!defaultEdgeConfigClient) {\n    defaultEdgeConfigClient = createClient(process.env.EDGE_CONFIG);\n  }\n}\n\n/**\n * Reads a single item from the default Edge Config.\n *\n * This is a convenience method which reads the default Edge Config.\n * It is conceptually similar to `createClient(process.env.EDGE_CONFIG).get()`.\n *\n * @see {@link EdgeConfigClient.get}\n * @param key - the key to read\n * @returns the value stored under the given key, or undefined\n */\nexport const get: EdgeConfigClient['get'] = (...args) => {\n  init();\n  return defaultEdgeConfigClient.get(...args);\n};\n\n/**\n * Reads multiple or all values.\n *\n * This is a convenience method which reads the default Edge Config.\n * It is conceptually similar to `createClient(process.env.EDGE_CONFIG).getAll()`.\n *\n * @see {@link EdgeConfigClient.getAll}\n * @param keys - the keys to read\n * @returns the value stored under the given key, or undefined\n */\nexport const getAll: EdgeConfigClient['getAll'] = (...args) => {\n  init();\n  return defaultEdgeConfigClient.getAll(...args);\n};\n\n/**\n * Check if a given key exists in the Edge Config.\n *\n * This is a convenience method which reads the default Edge Config.\n * It is conceptually similar to `createClient(process.env.EDGE_CONFIG).has()`.\n *\n * @see {@link EdgeConfigClient.has}\n * @param key - the key to check\n * @returns true if the given key exists in the Edge Config.\n */\nexport const has: EdgeConfigClient['has'] = (...args) => {\n  init();\n  return defaultEdgeConfigClient.has(...args);\n};\n\n/**\n * Get the digest of the Edge Config.\n *\n * This is a convenience method which reads the default Edge Config.\n * It is conceptually similar to `createClient(process.env.EDGE_CONFIG).digest()`.\n *\n * @see {@link EdgeConfigClient.digest}\n * @returns The digest of the Edge Config.\n */\nexport const digest: EdgeConfigClient['digest'] = (...args) => {\n  init();\n  return defaultEdgeConfigClient.digest(...args);\n};\n\n/**\n * Safely clones a read-only Edge Config object and makes it mutable.\n */\nexport function clone<T = EdgeConfigValue>(edgeConfigValue: T): T {\n  // Use JSON.parse and JSON.stringify instead of anything else due to\n  // the value possibly being a Proxy object.\n  return JSON.parse(JSON.stringify(edgeConfigValue)) as T;\n}\n","{\n  \"name\": \"@vercel/edge-config\",\n  \"version\": \"1.4.0\",\n  \"description\": \"Ultra-low latency data at the edge\",\n  \"homepage\": \"https://vercel.com\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/vercel/storage.git\",\n    \"directory\": \"packages/edge-config\"\n  },\n  \"license\": \"Apache-2.0\",\n  \"sideEffects\": false,\n  \"type\": \"module\",\n  \"exports\": {\n    \"import\": \"./dist/index.js\",\n    \"require\": \"./dist/index.cjs\"\n  },\n  \"main\": \"./dist/index.cjs\",\n  \"module\": \"./dist/index.js\",\n  \"files\": [\n    \"dist\"\n  ],\n  \"scripts\": {\n    \"build\": \"tsup\",\n    \"dev\": \"tsup --watch --clean=false\",\n    \"lint\": \"eslint --max-warnings=0 .\",\n    \"prepublishOnly\": \"pnpm run build\",\n    \"prettier-check\": \"prettier --check .\",\n    \"publint\": \"npx publint\",\n    \"test\": \"pnpm run test:node && pnpm run test:edge && pnpm run test:common\",\n    \"test:common\": \"jest --env @edge-runtime/jest-environment .common.test.ts && jest --env node .common.test.ts\",\n    \"test:edge\": \"jest --env @edge-runtime/jest-environment .edge.test.ts\",\n    \"test:node\": \"jest --env node .node.test.ts\",\n    \"type-check\": \"tsc --noEmit\"\n  },\n  \"jest\": {\n    \"preset\": \"ts-jest\",\n    \"setupFiles\": [\n      \"<rootDir>/jest/setup.js\"\n    ],\n    \"testEnvironment\": \"node\"\n  },\n  \"dependencies\": {\n    \"@vercel/edge-config-fs\": \"workspace:*\"\n  },\n  \"devDependencies\": {\n    \"@changesets/cli\": \"2.27.9\",\n    \"@edge-runtime/jest-environment\": \"2.3.10\",\n    \"@edge-runtime/types\": \"2.2.9\",\n    \"@types/jest\": \"29.5.13\",\n    \"@types/node\": \"22.7.3\",\n    \"eslint\": \"8.56.0\",\n    \"eslint-config-custom\": \"workspace:*\",\n    \"jest\": \"29.7.0\",\n    \"jest-fetch-mock\": \"3.0.3\",\n    \"node-domexception\": \"2.0.1\",\n    \"prettier\": \"3.3.3\",\n    \"ts-jest\": \"29.2.5\",\n    \"tsconfig\": \"workspace:*\",\n    \"tsup\": \"8.3.0\",\n    \"typescript\": \"5.6.2\"\n  },\n  \"peerDependencies\": {\n    \"@opentelemetry/api\": \"^1.7.0\"\n  },\n  \"peerDependenciesMeta\": {\n    \"@opentelemetry/api\": {\n      \"optional\": true\n    }\n  },\n  \"engines\": {\n    \"node\": \">=14.6\"\n  }\n}\n","import type { Tracer, Attributes, TracerProvider } from '@opentelemetry/api';\nimport { name as pkgName, version } from '../../package.json';\n\n// Use a symbol to avoid having global variable that is scoped to this file,\n// as it can lead to issues with cjs and mjs being used at the same time.\nconst edgeConfigTraceSymbol = Symbol.for('@vercel/edge-config:global-trace');\n\n/**\n * Allows setting the `@opentelemetry/api` tracer provider to generate traces\n * for Edge Config related operations.\n */\nexport function setTracerProvider(tracer: TracerProvider): void {\n  Reflect.set(globalThis, edgeConfigTraceSymbol, tracer);\n}\n\nfunction getTracer(): Tracer | undefined {\n  const maybeTraceApi = Reflect.get(globalThis, edgeConfigTraceSymbol) as\n    | undefined\n    | TracerProvider;\n  return maybeTraceApi?.getTracer(pkgName, version);\n}\n\nfunction isPromise<T>(p: unknown): p is Promise<T> {\n  return (\n    p !== null &&\n    typeof p === 'object' &&\n    'then' in p &&\n    typeof p.then === 'function'\n  );\n}\n\n/* eslint-disable @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-explicit-any -- bc */\nexport function trace<F extends (...args: any) => any>(\n  fn: F,\n  options: {\n    name: string;\n    /** Defaults to `true`. If set to `false`, it'll trace regardless of `EDGE_CONFIG_TRACE_VERBOSE`. */\n    isVerboseTrace?: boolean;\n    attributes?: Attributes;\n    attributesSuccess?: (\n      result: ReturnType<F> extends PromiseLike<infer U> ? U : ReturnType<F>,\n    ) => Attributes;\n    attributesError?: (error: Error) => Attributes;\n  } = {\n    name: fn.name,\n  },\n): F {\n  const traced = function (this: unknown, ...args: unknown[]): unknown {\n    const tracer = getTracer();\n    if (!tracer) return fn.apply(this, args);\n\n    const shouldTrace =\n      process.env.EDGE_CONFIG_TRACE_VERBOSE === 'true' ||\n      options.isVerboseTrace === false;\n    if (!shouldTrace) return fn.apply(this, args);\n\n    return tracer.startActiveSpan(options.name, (span) => {\n      if (options.attributes) span.setAttributes(options.attributes);\n\n      try {\n        const result = fn.apply(this, args);\n\n        if (isPromise(result)) {\n          result\n            .then((value) => {\n              if (options.attributesSuccess) {\n                span.setAttributes(\n                  options.attributesSuccess(\n                    value as ReturnType<F> extends PromiseLike<infer U>\n                      ? U\n                      : ReturnType<F>,\n                  ),\n                );\n              }\n\n              span.setStatus({ code: 1 }); // 1 = Ok\n              span.end();\n            })\n            .catch((error) => {\n              if (options.attributesError) {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument -- k\n                span.setAttributes(options.attributesError(error));\n              }\n\n              span.setStatus({\n                code: 2, // 2 = Error\n                message: error instanceof Error ? error.message : undefined,\n              });\n\n              span.end();\n            });\n        } else {\n          if (options.attributesSuccess) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument -- k\n            span.setAttributes(options.attributesSuccess(result));\n          }\n\n          span.setStatus({ code: 1 }); // 1 = Ok\n          span.end();\n        }\n\n        return result as unknown;\n      } catch (error: any) {\n        if (options.attributesError) {\n          span.setAttributes(options.attributesError(error as Error));\n        }\n\n        span.setStatus({\n          code: 2, // 2 = Error\n          message: error instanceof Error ? error.message : undefined,\n        });\n\n        span.end();\n\n        throw error;\n      }\n    });\n  };\n\n  return traced as unknown as F;\n}\n/* eslint-enable @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-explicit-any -- k */\n","import type { Connection } from '../types';\nimport { trace } from './tracing';\n\nexport const ERRORS = {\n  UNAUTHORIZED: '@vercel/edge-config: Unauthorized',\n  EDGE_CONFIG_NOT_FOUND: '@vercel/edge-config: Edge Config not found',\n};\n\nexport class UnexpectedNetworkError extends Error {\n  constructor(res: Response) {\n    super(\n      `@vercel/edge-config: Unexpected error due to response with status code ${res.status}`,\n    );\n  }\n}\n\n/**\n * Checks if an object has a property\n */\nexport function hasOwnProperty<X, Y extends PropertyKey>(\n  obj: X,\n  prop: Y,\n): obj is X & Record<Y, unknown> {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nexport function pick<T, K extends keyof T>(obj: T, keys: K[]): Pick<T, K> {\n  const ret: Partial<T> = {};\n  keys.forEach((key) => {\n    ret[key] = obj[key];\n  });\n  return ret as Pick<T, K>;\n}\n\nexport function assertIsKey(key: unknown): asserts key is string {\n  if (typeof key !== 'string') {\n    throw new Error('@vercel/edge-config: Expected key to be a string');\n  }\n}\n\nexport function isEmptyKey(key: string): boolean {\n  return key.trim() === '';\n}\n\nexport function assertIsKeys(keys: unknown): asserts keys is string[] {\n  if (!Array.isArray(keys) || keys.some((key) => typeof key !== 'string')) {\n    throw new Error(\n      '@vercel/edge-config: Expected keys to be an array of string',\n    );\n  }\n}\n\n/**\n * Creates a deep clone of an object.\n */\nexport const clone = trace(\n  function clone<T>(value: T): T {\n    // only available since node v17.0.0\n    if (typeof structuredClone === 'function') return structuredClone<T>(value);\n\n    // poor man's polyfill for structuredClone\n    if (value === undefined) return value;\n    return JSON.parse(JSON.stringify(value)) as T;\n  },\n  { name: 'clone' },\n);\n\n/**\n * Parses internal edge config connection strings\n *\n * Internal edge config connection strings are those which are native to Vercel.\n *\n * Internal Edge Config Connection Strings look like this:\n * https://edge-config.vercel.com/<edgeConfigId>?token=<token>\n */\nfunction parseVercelConnectionStringFromUrl(text: string): Connection | null {\n  try {\n    const url = new URL(text);\n    if (url.host !== 'edge-config.vercel.com') return null;\n    if (url.protocol !== 'https:') return null;\n    if (!url.pathname.startsWith('/ecfg')) return null;\n\n    const id = url.pathname.split('/')[1];\n    if (!id) return null;\n\n    const token = url.searchParams.get('token');\n    if (!token || token === '') return null;\n\n    return {\n      type: 'vercel',\n      baseUrl: `https://edge-config.vercel.com/${id}`,\n      id,\n      version: '1',\n      token,\n    };\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Parses a connection string with the following format:\n * `edge-config:id=ecfg_abcd&token=xxx`\n */\nfunction parseConnectionFromQueryParams(text: string): Connection | null {\n  try {\n    if (!text.startsWith('edge-config:')) return null;\n    const params = new URLSearchParams(text.slice(12));\n\n    const id = params.get('id');\n    const token = params.get('token');\n\n    if (!id || !token) return null;\n\n    return {\n      type: 'vercel',\n      baseUrl: `https://edge-config.vercel.com/${id}`,\n      id,\n      version: '1',\n      token,\n    };\n  } catch {\n    // no-op\n  }\n\n  return null;\n}\n\n/**\n * Parses info contained in connection strings.\n *\n * This works with the vercel-provided connection strings, but it also\n * works with custom connection strings.\n *\n * The reason we support custom connection strings is that it makes testing\n * edge config really straightforward. Users can provide  connection strings\n * pointing to their own servers and then either have a custom server\n * return the desired values or even intercept requests with something like\n * msw.\n *\n * To allow interception we need a custom connection string as the\n * edge-config.vercel.com connection string might not always go over\n * the network, so msw would not have a chance to intercept.\n */\n/**\n * Parses external edge config connection strings\n *\n * External edge config connection strings are those which are foreign to Vercel.\n *\n * External Edge Config Connection Strings look like this:\n * - https://example.com/?id=<edgeConfigId>&token=<token>\n * - https://example.com/<edgeConfigId>?token=<token>\n */\nfunction parseExternalConnectionStringFromUrl(\n  connectionString: string,\n): Connection | null {\n  try {\n    const url = new URL(connectionString);\n\n    let id: string | null = url.searchParams.get('id');\n    const token = url.searchParams.get('token');\n    const version = url.searchParams.get('version') || '1';\n\n    // try to determine id based on pathname if it wasn't provided explicitly\n    if (!id || url.pathname.startsWith('/ecfg_')) {\n      id = url.pathname.split('/')[1] || null;\n    }\n\n    if (!id || !token) return null;\n\n    // remove all search params for use as baseURL\n    url.search = '';\n\n    // try to parse as external connection string\n    return {\n      type: 'external',\n      baseUrl: url.toString(),\n      id,\n      token,\n      version,\n    };\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Parse the edgeConfigId and token from an Edge Config Connection String.\n *\n * Edge Config Connection Strings usually look like one of the following:\n *  - https://edge-config.vercel.com/<edgeConfigId>?token=<token>\n *  - edge-config:id=<edgeConfigId>&token=<token>\n *\n * @param text - A potential Edge Config Connection String\n * @returns The connection parsed from the given Connection String or null.\n */\nexport function parseConnectionString(\n  connectionString: string,\n): Connection | null {\n  return (\n    parseConnectionFromQueryParams(connectionString) ||\n    parseVercelConnectionStringFromUrl(connectionString) ||\n    parseExternalConnectionStringFromUrl(connectionString)\n  );\n}\n","import { trace } from './tracing';\n\ninterface CachedResponseEntry {\n  etag: string;\n  response: string;\n  headers: Record<string, string>;\n  status: number;\n  time: number;\n}\n\ntype FetchOptions = Omit<RequestInit, 'headers'> & { headers?: Headers };\n\ninterface ResponseWithCachedResponse extends Response {\n  cachedResponseBody?: unknown;\n}\n\n/**\n * Creates a new response based on a cache entry\n */\nfunction createResponse(\n  cachedResponseEntry: CachedResponseEntry,\n): ResponseWithCachedResponse {\n  return new Response(cachedResponseEntry.response, {\n    headers: {\n      ...cachedResponseEntry.headers,\n      Age: String(\n        // age header may not be 0 when serving stale content, must be >= 1\n        Math.max(1, Math.floor((Date.now() - cachedResponseEntry.time) / 1000)),\n      ),\n    },\n    status: cachedResponseEntry.status,\n  });\n}\n\n/**\n * Used for bad responses like 500s\n */\nfunction createHandleStaleIfError(\n  cachedResponseEntry: CachedResponseEntry,\n  staleIfError: number | null,\n) {\n  return function handleStaleIfError(\n    response: ResponseWithCachedResponse,\n  ): ResponseWithCachedResponse {\n    switch (response.status) {\n      case 500:\n      case 502:\n      case 503:\n      case 504:\n        return typeof staleIfError === 'number' &&\n          cachedResponseEntry.time < Date.now() + staleIfError * 1000\n          ? createResponse(cachedResponseEntry)\n          : response;\n      default:\n        return response;\n    }\n  };\n}\n\n/**\n * Used on network errors which end up throwing\n */\nfunction createHandleStaleIfErrorException(\n  cachedResponseEntry: CachedResponseEntry,\n  staleIfError: number | null,\n) {\n  return function handleStaleIfError(\n    reason: unknown,\n  ): ResponseWithCachedResponse {\n    if (\n      typeof staleIfError === 'number' &&\n      cachedResponseEntry.time < Date.now() + staleIfError * 1000\n    ) {\n      return createResponse(cachedResponseEntry);\n    }\n    throw reason;\n  };\n}\n\n/**\n * A cache of request urls & auth headers and the resulting responses.\n *\n * This cache does not use Response instances as the cache value as reusing\n * responses across requests leads to issues in Cloudflare Workers.\n */\nexport const cache = new Map<string, CachedResponseEntry>();\n\nfunction extractStaleIfError(cacheControlHeader: string | null): number | null {\n  if (!cacheControlHeader) return null;\n  const matched = /stale-if-error=(?<staleIfError>\\d+)/i.exec(\n    cacheControlHeader,\n  );\n  return matched?.groups ? Number(matched.groups.staleIfError) : null;\n}\n\n/**\n * This is similar to fetch, but it also implements ETag semantics, and\n * it implmenets stale-if-error semantics.\n */\nexport const fetchWithCachedResponse = trace(\n  async function fetchWithCachedResponse(\n    url: string,\n    options: FetchOptions = {},\n  ): Promise<ResponseWithCachedResponse> {\n    const { headers: customHeaders = new Headers(), ...customOptions } =\n      options;\n    const authHeader = customHeaders.get('Authorization');\n    const cacheKey = `${url},${authHeader || ''}`;\n\n    const cachedResponseEntry = cache.get(cacheKey);\n\n    if (cachedResponseEntry) {\n      const { etag, response: cachedResponse } = cachedResponseEntry;\n      const headers = new Headers(customHeaders);\n      headers.set('If-None-Match', etag);\n\n      const staleIfError = extractStaleIfError(headers.get('Cache-Control'));\n\n      const res: ResponseWithCachedResponse = await fetch(url, {\n        ...customOptions,\n        headers,\n      }).then(\n        createHandleStaleIfError(cachedResponseEntry, staleIfError),\n        createHandleStaleIfErrorException(cachedResponseEntry, staleIfError),\n      );\n\n      if (res.status === 304) {\n        res.cachedResponseBody = JSON.parse(cachedResponse);\n        return res;\n      }\n\n      const newETag = res.headers.get('ETag');\n      if (res.ok && newETag)\n        cache.set(cacheKey, {\n          etag: newETag,\n          response: await res.clone().text(),\n          headers: Object.fromEntries(res.headers.entries()),\n          status: res.status,\n          time: Date.now(),\n        });\n      return res;\n    }\n\n    const res = await fetch(url, options);\n    const etag = res.headers.get('ETag');\n    if (res.ok && etag) {\n      cache.set(cacheKey, {\n        etag,\n        response: await res.clone().text(),\n        headers: Object.fromEntries(res.headers.entries()),\n        status: res.status,\n        time: Date.now(),\n      });\n    }\n\n    return res;\n  },\n  {\n    name: 'fetchWithCachedResponse',\n    attributesSuccess(result) {\n      return {\n        status: result.status,\n      };\n    },\n  },\n);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}